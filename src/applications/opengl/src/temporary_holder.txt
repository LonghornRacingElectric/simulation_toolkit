#include <iostream>
#include <vector>
#include <cmath>

#include "../glm/glm.hpp"
#include "../glm/gtc/matrix_transform.hpp"
#include "../glm/gtc/type_ptr.hpp"
#include "glad.h"
#include "GLFW/glfw3.h"
#include "sphere.h"
#include "rod.h"
#include "imgui.h"

// === Global Variables ===
unsigned int shaderProgram;
glm::vec3 spherePosition(0.0f, 0.0f, 0.0f);

// Sphere state
int x = 0, y = 0, z = 0;
bool createNewNode = false;
std::vector<SphereInstance> spheres;

// Rod state
float xyzRodEnd1[3] = { -1.0f, 0.0f, 0.0f };
float xyzRodEnd2[3] = { 1.0f, 0.0f, 0.0f };
bool createNewRod = false;
std::vector<RodInstance> rods;

// Camera
float camAngleX = 0.0f, camAngleY = 0.0f, camDistance = 5.0f;
float zoom = 1.0f;

// === Utility Functions ===
void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
    glViewport(0, 0, width, height);
    glm::mat4 projection = glm::ortho(-3.0f, 3.0f, -2.0f, 2.0f, 0.1f, 100.0f);
    unsigned int projectionLoc = glGetUniformLocation(shaderProgram, "projection");
    glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));
}

void setSpherePosition(float x_, float y_, float z_) {
    spherePosition = glm::vec3(x_, y_, z_);
}

int main() {
    // === GLFW + GLAD Initialization ===
    if (!glfwInit()) return -1;
    GLFWwindow* window = glfwCreateWindow(800, 600, "ImGui Rod System", NULL, NULL);
    glfwMakeContextCurrent(window);
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) return -1;

    glEnable(GL_DEPTH_TEST);
    glClearColor(0.25f, 0.5f, 0.75f, 1.0f);
    initImGui(window);

    // === Geometry Setup ===
    float radius = 0.5f;
    unsigned int stacks = 20, slices = 20;
    float* sphereVertices = nullptr;
    unsigned int* sphereIndices = nullptr;
    unsigned int sphereVertCount = 0, sphereIndexCount = 0;
    generateSphere(radius, stacks, slices, sphereVertices, sphereIndices, sphereVertCount, sphereIndexCount);

    unsigned int VAO, VBO, EBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &EBO);
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sphereVertCount * 3 * sizeof(float), sphereVertices, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sphereIndexCount * sizeof(unsigned int), sphereIndices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    float rodRadius = 0.25f, rodHeight = 2.0f;
    unsigned int rodSlices = 30, rodVAO, rodVBO, rodEBO;
    float* rodVertices = nullptr;
    unsigned int* rodIndices = nullptr;
    unsigned int rodVertexCount = 0, rodIndexCount = 0;
    generateRod(rodRadius, rodHeight, rodSlices, rodVertices, rodIndices, rodVertexCount, rodIndexCount);

    glGenVertexArrays(1, &rodVAO);
    glGenBuffers(1, &rodVBO);
    glGenBuffers(1, &rodEBO);
    glBindVertexArray(rodVAO);
    glBindBuffer(GL_ARRAY_BUFFER, rodVBO);
    glBufferData(GL_ARRAY_BUFFER, rodVertexCount * 3 * sizeof(float), rodVertices, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, rodEBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, rodIndexCount * sizeof(unsigned int), rodIndices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // === Shaders ===
    const char* vs = "#version 330 core\nlayout (location = 0) in vec3 aPos;\nuniform mat4 model, view, projection;\nvoid main() { gl_Position = projection * view * model * vec4(aPos, 1.0); }";
    const char* fs = "#version 330 core\n"
    "out vec4 FragColor;\n"
    "uniform vec4 objectColor;\n"
    "void main() {\n"
    "   FragColor = objectColor;\n"
    "}\0";

    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vs, NULL); glCompileShader(vertexShader);
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fs, NULL); glCompileShader(fragmentShader);
    shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
    glUseProgram(shaderProgram);

    unsigned int modelLoc = glGetUniformLocation(shaderProgram, "model");
    unsigned int viewLoc = glGetUniformLocation(shaderProgram, "view");
    unsigned int projLoc = glGetUniformLocation(shaderProgram, "projection");
    unsigned int colorLoc = glGetUniformLocation(shaderProgram, "objectColor");

    glm::mat4 projection = glm::ortho(-3.0f, 3.0f, -2.0f, 2.0f, 0.1f, 100.0f);
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(projection));
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // ----- Initialize 4 nodes and 4 rods -----
    // Add 4 spheres at the specified coordinates
    spheres.push_back({ glm::vec3(1.0f, 1.0f, 0.0f), 0.0f });    // Node at (1, 1)
    spheres.push_back({ glm::vec3(1.0f, -1.0f, 0.0f), 0.0f });   // Node at (1, -1)
    spheres.push_back({ glm::vec3(-1.0f, 1.0f, 0.0f), 0.0f });   // Node at (-1, 1)
    spheres.push_back({ glm::vec3(-1.0f, -1.0f, 0.0f), 0.0f });  // Node at (-1, -1)
    
    // Add 4 rods connecting the nodes to form a square
    rods.push_back({ glm::vec3(1.0f, 1.0f, 0.0f), glm::vec3(1.0f, -1.0f, 0.0f) });     // Right edge
    rods.push_back({ glm::vec3(1.0f, -1.0f, 0.0f), glm::vec3(-1.0f, -1.0f, 0.0f) });   // Bottom edge
    rods.push_back({ glm::vec3(-1.0f, -1.0f, 0.0f), glm::vec3(-1.0f, 1.0f, 0.0f) });   // Left edge
    rods.push_back({ glm::vec3(-1.0f, 1.0f, 0.0f), glm::vec3(1.0f, 1.0f, 0.0f) });     // Top edge

    // === Main Loop ===
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        renderImGuiControls();

        float radX = glm::radians(camAngleX), radY = glm::radians(camAngleY);
        float camX = camDistance * cos(radX) * sin(radY);
        float camY = camDistance * sin(radX);
        float camZ = camDistance * cos(radX) * cos(radY);
        glm::mat4 view = glm::lookAt(glm::vec3(camX, camY, camZ), glm::vec3(0), glm::vec3(0, 1, 0));
        view = view * glm::scale(glm::mat4(1.0f), glm::vec3(zoom));
        glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));

        if (createNewNode) {
            spheres.push_back({ spherePosition, 0.0f });
            createNewNode = false;
        }

        if (createNewRod) {
            rods.push_back({ glm::vec3(xyzRodEnd1[0], xyzRodEnd1[1], xyzRodEnd1[2]),
                             glm::vec3(xyzRodEnd2[0], xyzRodEnd2[1], xyzRodEnd2[2]) });
            createNewRod = false;
        }

        // === Draw Spheres ===
        glBindVertexArray(VAO);
        for (auto& s : spheres) {
            glm::mat4 model = glm::translate(glm::mat4(1.0f), s.position);  // Apply sphere position transformation
            glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
            glUniform4fv(colorLoc, 1, glm::value_ptr(s.color));  // Set sphere color
            glDrawElements(GL_TRIANGLES, sphereIndexCount, GL_UNSIGNED_INT, 0);
        }

        // === Draw Rods ===
        glBindVertexArray(rodVAO);
        for (auto& r : rods) {
            // Calculate direction, length, and midpoint for the rod
            glm::vec3 dir = r.end2 - r.end1;
            float length = glm::length(dir);  // Length of the rod
            glm::vec3 mid = (r.end1 + r.end2) * 0.5f;  // Midpoint of the rod

            // Normalize direction vector
            glm::vec3 dirNormalized = glm::normalize(dir);

            // Calculate rotation axis and angle to align the rod with the correct direction
            glm::vec3 axis = glm::cross(glm::vec3(0, 1, 0), dirNormalized);
            float angle = acos(glm::clamp(glm::dot(glm::vec3(0, 1, 0), dirNormalized), -1.0f, 1.0f));

            // Apply the transformation to the rod: translation, rotation, scaling
            glm::mat4 model = glm::translate(glm::mat4(1.0f), mid);  // Translate to the rod's midpoint
            if (glm::length(axis) > 0.001f) {
                model = glm::rotate(model, angle, glm::normalize(axis));  // Rotate to align with the direction
            }
            model = glm::scale(model, glm::vec3(1.0f, length / rodHeight, 1.0f));  // Scale the rod to the correct length

            // Apply the same view transformation as for spheres, ensuring they are in the same space
            glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
            glUniform4fv(colorLoc, 1, glm::value_ptr(r.color));  // Set rod color

            glDrawElements(GL_TRIANGLES, rodIndexCount, GL_UNSIGNED_INT, 0);
        }

        // Render ImGui UI controls
        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        glfwSwapBuffers(window);
    }

    // Cleanup
    cleanupImGui();
    glfwTerminate();
    delete[] sphereVertices;
    delete[] sphereIndices;
    delete[] rodVertices;
    delete[] rodIndices;

    return 0;
}
